<!DOCTYPE html>
<html lang="es">
<head>
    <!-- [El head permanece igual que antes] -->
</head>
<body>
    <!-- [Todo el contenido previo permanece igual hasta la sección de Análisis Filosófico Profundo] -->

    <section>
        <h2>Análisis Filosófico Profundo</h2>
        
        <!-- Nuevo mapa de vigilancia digital -->
        <div class="content-box">
            <h3>Mapa de Vigilancia Digital Global</h3>
            <div class="model-container" id="threatMap">
                <div class="map-overlay">
                    <div class="map-legend">
                        <h4>Leyenda del Mapa</h4>
                        <div class="legend-item">
                            <span class="legend-color surveillance"></span>
                            <span>Vigilancia estatal</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color corporate"></span>
                            <span>Rastreo corporativo</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color data-flow"></span>
                            <span>Flujo de datos</span>
                        </div>
                    </div>
                    <div class="map-stats">
                        <div class="stat-item">
                            <div class="stat-value">247</div>
                            <div class="stat-label">Países bajo vigilancia</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">3.8B</div>
                            <div class="stat-label">Personas monitorizadas</div>
                        </div>
                    </div>
                </div>
            </div>
            <p>Este mapa simulado representa los flujos globales de vigilancia digital en tiempo real. Cada nodo representa un centro de recolección de datos, mientras que las conexiones muestran cómo la información personal circula entre gobiernos, corporaciones y terceros.</p>
            
            <div class="quote">
                <p>"El mapa no es el territorio, pero en la era digital, el mapa crea el territorio al determinar qué conductas son visibles y cuáles permanecen ocultas."</p>
                <div class="author">Adaptado de Alfred Korzybski</div>
            </div>
        </div>

        <!-- [El resto de tu contenido permanece igual] -->
    </section>

    <style>
        /* Estilos para el mapa de vigilancia */
        #threatMap {
            position: relative;
            height: 500px;
            background: #0a0a30;
            overflow: hidden;
        }
        
        .map-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 40, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--accent);
            max-width: 250px;
        }
        
        .map-legend h4 {
            margin-top: 0;
            color: var(--primary);
            border-bottom: 1px solid var(--secondary);
            padding-bottom: 5px;
        }
        
        .legend-item {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            margin-right: 10px;
            border-radius: 3px;
        }
        
        .legend-color.surveillance {
            background: #ff00aa;
            box-shadow: 0 0 5px #ff00aa;
        }
        
        .legend-color.corporate {
            background: #00f7ff;
            box-shadow: 0 0 5px #00f7ff;
        }
        
        .legend-color.data-flow {
            background: #7b2dff;
            box-shadow: 0 0 5px #7b2dff;
        }
        
        .map-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 0 10px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
            text-shadow: 0 0 5px rgba(0, 247, 255, 0.5);
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: var(--light);
            opacity: 0.8;
        }
        
        /* Animación del mapa (simulada con CSS) */
        #threatMap::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 0, 170, 0.1), transparent 70%),
                radial-gradient(circle at 80% 70%, rgba(0, 247, 255, 0.1), transparent 70%);
            animation: pulse 15s infinite alternate;
        }
        
        @keyframes pulse {
            0% { opacity: 0.3; }
            100% { opacity: 0.7; }
        }
    </style>

    <script>
        // Script para el mapa interactivo
        function initThreatMap() {
            const container = document.getElementById('threatMap');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Escena
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a20);
            
            // Cámara
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            container.insertBefore(renderer.domElement, container.firstChild);
            
            // Crear un globo terráqueo
            const geometry = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x0a0a30,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            
            // Puntos de vigilancia (simulados)
            const pointsGeometry = new THREE.BufferGeometry();
            const pointsMaterial = new THREE.PointsMaterial({
                color: 0x00f7ff,
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });
            
            const pointsCount = 200;
            const positions = new Float32Array(pointsCount * 3);
            
            for (let i = 0; i < pointsCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const radius = 2.1 + (Math.random() * 0.2);
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            
            pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const points = new THREE.Points(pointsGeometry, pointsMaterial);
            scene.add(points);
            
            // Conexiones (simuladas)
            const linesGeometry = new THREE.BufferGeometry();
            const linesMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff00aa,
                transparent: true,
                opacity: 0.3
            });
            
            const linesPositions = new Float32Array(pointsCount * 3 * 2);
            for (let i = 0; i < pointsCount; i++) {
                if (Math.random() > 0.7) {
                    const j = Math.floor(Math.random() * pointsCount);
                    
                    linesPositions[i * 6] = positions[i * 3];
                    linesPositions[i * 6 + 1] = positions[i * 3 + 1];
                    linesPositions[i * 6 + 2] = positions[i * 3 + 2];
                    
                    linesPositions[i * 6 + 3] = positions[j * 3];
                    linesPositions[i * 6 + 4] = positions[j * 3 + 1];
                    linesPositions[i * 6 + 5] = positions[j * 3 + 2];
                }
            }
            
            linesGeometry.setAttribute('position', new THREE.BufferAttribute(linesPositions, 3));
            const lines = new THREE.LineSegments(linesGeometry, linesMaterial);
            scene.add(lines);
            
            // Animación
            function animate() {
                requestAnimationFrame(animate);
                
                sphere.rotation.y += 0.001;
                points.rotation.y += 0.0005;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Redimensionamiento
            window.addEventListener('resize', function() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        // Inicializar el mapa cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', function() {
            initThreatMap();
            // [El resto de tus inicializaciones]
        });
    </script>
</body>
</html>
